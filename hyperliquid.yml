x-logging: &logging
  logging:
    driver: json-file
    options:
      max-size: 100m
      max-file: "3"
      tag: '{{.ImageName}}|{{.Name}}|{{.ImageFullID}}|{{.FullID}}'

services:
  consensus:
    build:
      context: ./hyperliquid
      args:
        - PUB_KEY_URL=${PUB_KEY_URL}
        - USERNAME=${USERNAME:-hyperliquid}
        - CHAIN=${CHAIN:-Mainnet}
    image: hyperliquid:local
    pull_policy: never
    user: "${USERNAME:-hyperliquid}"
    restart: unless-stopped
    environment:
      - CHAIN=${CHAIN:-Mainnet}
      - NODE_TYPE=${NODE_TYPE:-non-validator}
      - LOG_LEVEL=${LOG_LEVEL:-info}
      - ENABLE_EVM_RPC=${ENABLE_EVM_RPC:-false}
      - VALIDATOR_PRIVATE_KEY=${VALIDATOR_PRIVATE_KEY:-}
      - MAINNET_ROOT_IPS=${MAINNET_ROOT_IPS:-}
      - TESTNET_ROOT_IPS=${TESTNET_ROOT_IPS:-}
      - RESERVED_PEER_IPS=${RESERVED_PEER_IPS:-}
      - EXTRA_FLAGS=${EXTRA_FLAGS:-}
      - FIREWALL_IPS=${FIREWALL_IPS:-}
    ports:
      - ${P2P_PORT_RANGE:-4000-4010}:${P2P_PORT_RANGE:-4000-4010}/tcp
      - ${P2P_PORT_RANGE:-4000-4010}:${P2P_PORT_RANGE:-4000-4010}/udp
    <<: *logging
    volumes:
      - consensus-data:/home/${USERNAME}
    entrypoint: ["docker-entrypoint.sh"]
    labels:
      - traefik.enable=true
      - traefik.http.routers.${RPC_HOST}.service=${RPC_HOST}
      - traefik.http.routers.${RPC_HOST}.entrypoints=websecure
      - traefik.http.routers.${RPC_HOST}.rule=Host(`${RPC_HOST}.${DOMAIN}`)
      - traefik.http.routers.${RPC_HOST}.tls.certresolver=letsencrypt
      - traefik.http.routers.${RPC_HOST}lb.service=${RPC_HOST}
      - traefik.http.routers.${RPC_HOST}lb.entrypoints=websecure
      - traefik.http.routers.${RPC_HOST}lb.rule=Host(`${RPC_LB}.${DOMAIN}`)
      - traefik.http.routers.${RPC_HOST}lb.tls.certresolver=letsencrypt
      - traefik.http.services.${RPC_HOST}.loadbalancer.server.port=${EVM_RPC_PORT}
      - metrics.scrape=true
      - metrics.path=/metrics
      - metrics.port=${EVM_RPC_PORT}
      - metrics.instance=${RPC_HOST}
      - metrics.network=${CHAIN}

  pruner:
    build:
      context: ./pruner
      args:
        - USERNAME=${USERNAME:-hyperliquid}
    image: hyperliquid-pruner:local
    pull_policy: never
    user: root
    restart: unless-stopped
    environment:
      - LOG_LEVEL=${LOG_LEVEL:-info}
    volumes:
      - consensus-data:/home/${USERNAME}
    depends_on:
      - consensus
    <<: *logging


  validator-info:
    profiles: ["tools"]
    image: curlimages/curl:latest
    user: root
    container_name: validator-info
    environment:
      - CHAIN=${CHAIN:-Testnet}
    entrypoint:
      - /bin/sh
      - -c
      - |
          # 1) Install deps (quietly)
          apk add --no-cache bash jq >/dev/null

          # 2) Re-exec into Bash and run the real work
          exec /bin/bash -c '
            echo "CHAIN set to: $${CHAIN:-Testnet}" >&2

            if [ "$${CHAIN:-Testnet}" = "Mainnet" ]; then
              URL="https://api.hyperliquid.xyz/info"
            else
              URL="https://api.hyperliquid-testnet.xyz/info"
            fi

            echo "Querying validator summaries from: $$URL" >&2
            curl -sS -X POST -H "Content-Type: application/json" \
                --data "{\"type\":\"validatorSummaries\"}" "$$URL" | jq .

            echo "Done." >&2
          '
    <<: *logging

  cli:
    profiles: ["tools"]
    build:
      context: ./hyperliquid
      args:
        - PUB_KEY_URL=${PUB_KEY_URL}
        - USERNAME=${USERNAME:-hyperliquid}
        - CHAIN=${CHAIN:-Mainnet}
    image: hyperliquid:local
    pull_policy: never
    user: "${USERNAME:-hyperliquid}"
    container_name: hyperliquid-cli
    environment:
      - CHAIN=${CHAIN:-Mainnet}
      - NODE_TYPE=${NODE_TYPE:-non-validator}
      - LOG_LEVEL=${LOG_LEVEL:-info}
      - ENABLE_EVM_RPC=${ENABLE_EVM_RPC:-false}
      - VALIDATOR_PRIVATE_KEY=${VALIDATOR_PRIVATE_KEY:-}
      - MAINNET_ROOT_IPS=${MAINNET_ROOT_IPS:-}
      - TESTNET_ROOT_IPS=${TESTNET_ROOT_IPS:-}
      - EXTRA_FLAGS=${EXTRA_FLAGS:-}
    volumes:
      - consensus-data:/home/${USERNAME}
    entrypoint:
      - /bin/bash
      - -c
      - |
        if [ $# -eq 0 ]; then
          echo "Hyperliquid CLI Tool - Interactive Mode"
          exec bash
        else
          echo "Hyperliquid CLI Tool:"
          exec "$@"
        fi
      - --
    <<: *logging

  auto-unjail:
    image: curlimages/curl:latest
    user: root
    container_name: hyperliquid-auto-unjail
    restart: unless-stopped
    environment:
      - CHAIN=${CHAIN:-Testnet}
      - VALIDATOR_PRIVATE_KEY=${VALIDATOR_PRIVATE_KEY}
      - USERNAME=${USERNAME:-hyperliquid}
      - LOG_LEVEL=${LOG_LEVEL:-info}
    volumes:
      - consensus-data:/home/${USERNAME}
      - /var/run/docker.sock:/var/run/docker.sock:ro
    depends_on:
      - consensus
    entrypoint:
      - /bin/sh
      - -c
      - |
        # Install required packages
        echo "Installing required packages..."
        apk add --no-cache bash jq curl docker-cli >/dev/null 2>&1

        # Create auto-unjail script
        cat > /auto-unjail.sh << 'SCRIPT_EOF'
        #!/bin/bash

        # Configuration
        CHECK_INTERVAL=900  # 15 minutes in seconds
        UNJAIL_DELAY=1800    # 30 minutes delay before unjailing

        # Function to log with timestamp
        log() {
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] $$1"
        }

        # Function to get validator public key from private key
        get_validator_pubkey() {
            if [ -z "$$VALIDATOR_PRIVATE_KEY" ]; then
                log "ERROR: VALIDATOR_PRIVATE_KEY not set"
                return 1
            fi

            # Use docker exec to get the public key from the consensus container
            CONSENSUS_CONTAINER=$$(docker ps --filter "name=consensus" --format "{{.Names}}" | head -1)
            if [ -z "$$CONSENSUS_CONTAINER" ]; then
                log "ERROR: Consensus container not found"
                return 1
            fi

            PUBKEY=$$(docker exec "$$CONSENSUS_CONTAINER" /bin/bash -c "
                cd /home/$${USERNAME} &&
                ./hl-node --chain $$CHAIN --key $$VALIDATOR_PRIVATE_KEY print-address 2>/dev/null | grep -o '0x[a-fA-F0-9]\{40\}'
            " 2>/dev/null)

            if [ -z "$$PUBKEY" ]; then
                log "ERROR: Could not derive public key from private key"
                return 1
            fi

            echo "$$PUBKEY"
        }

        # Function to check if validator is jailed
        check_validator_status() {
            local pubkey="$$1"

            # Determine API URL based on chain
            if [ "$$CHAIN" = "Mainnet" ]; then
                URL="https://api.hyperliquid.xyz/info"
            else
                URL="https://api.hyperliquid-testnet.xyz/info"
            fi

            log "Checking validator status for signer pubkey: $$pubkey"

            # Query validator summaries
            RESPONSE=$$(curl -sS -X POST -H "Content-Type: application/json" \
                --data '{"type":"validatorSummaries"}' "$$URL" 2>/dev/null)

            if [ $$? -ne 0 ] || [ -z "$$RESPONSE" ]; then
                log "ERROR: Failed to query validator summaries"
                return 2
            fi

            # Check if our validator is in the list and if it's jailed (match by signer address)
            VALIDATOR_INFO=$$(echo "$$RESPONSE" | jq -r ".[] | select(.signer == \"$$pubkey\")")

            if [ -z "$$VALIDATOR_INFO" ]; then
                log "WARNING: Validator with signer address $$pubkey not found in validator summaries"
                return 1
            fi

            IS_JAILED=$$(echo "$$VALIDATOR_INFO" | jq -r '.isJailed // false')
            STAKE=$$(echo "$$VALIDATOR_INFO" | jq -r '.stake // "0"')
            VALIDATOR_NAME=$$(echo "$$VALIDATOR_INFO" | jq -r '.name // "Unknown"')

            log "Validator name: $$VALIDATOR_NAME"
            log "Validator stake: $$STAKE"
            log "Validator jailed status: $$IS_JAILED"

            if [ "$$IS_JAILED" = "true" ]; then
                return 0  # Jailed
            else
                return 1  # Not jailed
            fi
        }

        # Function to unjail validator
        unjail_validator() {
            log "Attempting to unjail validator..."

            if [ -z "$$VALIDATOR_PRIVATE_KEY" ]; then
                log "ERROR: VALIDATOR_PRIVATE_KEY not set"
                return 1
            fi

            # Find consensus container
            CONSENSUS_CONTAINER=$$(docker ps --filter "name=consensus" --format "{{.Names}}" | head -1)
            if [ -z "$$CONSENSUS_CONTAINER" ]; then
                log "ERROR: Consensus container not found"
                return 1
            fi

            # Execute unjail command in the consensus container
            RESULT=$$(docker exec "$$CONSENSUS_CONTAINER" /bin/bash -c "
                cd /home/$${USERNAME} &&
                ./hl-node --chain $$CHAIN --key $$VALIDATOR_PRIVATE_KEY send-signed-action '{\"type\": \"CSignerAction\", \"unjailSelf\": null}'
            " 2>&1)

            if [ $$? -eq 0 ]; then
                log "SUCCESS: Unjail command executed successfully"
                log "Result: $$RESULT"
                return 0
            else
                log "ERROR: Failed to execute unjail command"
                log "Error: $$RESULT"
                return 1
            fi
        }

        # Main monitoring loop
        main() {
            log "Starting Hyperliquid Auto-Unjail Monitor"
            log "Chain: $$CHAIN"
            log "Check interval: $$CHECK_INTERVAL seconds ($$(( CHECK_INTERVAL / 60 )) minutes)"
            log "Unjail delay: $$UNJAIL_DELAY seconds ($$(( UNJAIL_DELAY / 60 )) minutes)"

            # Wait for consensus container to be ready
            while true; do
                CONSENSUS_CONTAINER=$$(docker ps --filter "name=consensus" --format "{{.Names}}" | head -1)
                if [ -n "$$CONSENSUS_CONTAINER" ]; then
                    log "Found consensus container: $$CONSENSUS_CONTAINER"
                    break
                fi
                log "Waiting for consensus container to start..."
                sleep 30
            done

            # Get validator public key once at startup
            VALIDATOR_PUBKEY=$$(get_validator_pubkey)
            if [ $$? -ne 0 ]; then
                log "FATAL: Cannot determine validator public key. Exiting."
                exit 1
            fi

            log "Monitoring signer: $$VALIDATOR_PUBKEY"

            # State tracking
            JAIL_DETECTED_TIME=""

            while true; do
                log "Checking validator status..."

                if check_validator_status "$$VALIDATOR_PUBKEY"; then
                    # Validator is jailed
                    CURRENT_TIME=$$(date +%s)

                    if [ -z "$$JAIL_DETECTED_TIME" ]; then
                        # First time detecting jail
                        JAIL_DETECTED_TIME="$$CURRENT_TIME"
                        log "ALERT: Validator is JAILED! Will attempt unjail in $$(( UNJAIL_DELAY / 60 )) minutes..."
                    else
                        # Check if enough time has passed since jail detection
                        TIME_SINCE_JAIL=$$(( CURRENT_TIME - JAIL_DETECTED_TIME ))

                        if [ $$TIME_SINCE_JAIL -ge $$UNJAIL_DELAY ]; then
                            log "Jail timeout reached. Attempting to unjail validator..."

                            if unjail_validator; then
                                log "Unjail attempt completed successfully"
                                # Reset jail detection time to prevent immediate re-unjailing
                                JAIL_DETECTED_TIME=""
                            else
                                log "Unjail attempt failed. Will retry in next cycle."
                            fi
                        else
                            REMAINING_TIME=$$(( UNJAIL_DELAY - TIME_SINCE_JAIL ))
                            log "Validator still jailed. Time until unjail attempt: $$(( REMAINING_TIME / 60 )) minutes"
                        fi
                    fi
                else
                    # Validator is not jailed or error occurred
                    if [ -n "$$JAIL_DETECTED_TIME" ]; then
                        log "Validator is no longer jailed or status check failed"
                        JAIL_DETECTED_TIME=""
                    else
                        log "Validator status: OK (not jailed)"
                    fi
                fi

                log "Sleeping for $$(( CHECK_INTERVAL / 60 )) minutes until next check..."
                sleep $$CHECK_INTERVAL
            done
        }

        # Start the main function
        main
        SCRIPT_EOF

        # Make script executable
        chmod +x /auto-unjail.sh

        # Execute the auto-unjail script
        exec /auto-unjail.sh
    <<: *logging

  config-sync:
    profiles: ["tools"]
    image: hyperliquid:local
    pull_policy: never
    user: "${USERNAME:-hyperliquid}"
    environment:
      - USERNAME=${USERNAME:-hyperliquid}
      - CHAIN=${CHAIN:-Mainnet}
      - MAINNET_ROOT_IPS=${MAINNET_ROOT_IPS:-}
      - TESTNET_ROOT_IPS=${TESTNET_ROOT_IPS:-}
      - RESERVED_PEER_IPS=${RESERVED_PEER_IPS:-}
      - FIREWALL_IPS=${FIREWALL_IPS:-}
    volumes:
      - consensus-data:/home/${USERNAME}
    entrypoint:
      - /bin/bash
      - -c
      - |
        echo "🔄 Hyperliquid Configuration Sync"
        echo "Reading configuration from .env file..."

        # Function to create gossip config (same logic as docker-entrypoint.sh)
        create_gossip_config() {
          RESERVED_PEERS="$${RESERVED_PEER_IPS:-[]}"
          if [ "$${CHAIN}" = "Mainnet" ]; then
            if [ -n "$${MAINNET_ROOT_IPS}" ] && [ "$${MAINNET_ROOT_IPS}" != "[]" ]; then
              echo "Creating Mainnet gossip configuration..."
              cat > "$$HOME/override_gossip_config.json" <<EOF
        { "root_node_ips": $${MAINNET_ROOT_IPS}, "try_new_peers": false, "chain": "Mainnet", "reserved_peer_ips": $${RESERVED_PEERS} }
        EOF
              echo "✅ Created Mainnet gossip config"
            else
              echo "❌ Error: MAINNET_ROOT_IPS must be set and non-empty when CHAIN=Mainnet"
              return 1
            fi
          elif [ "$${CHAIN}" = "Testnet" ]; then
            if [ -n "$${TESTNET_ROOT_IPS}" ] && [ "$${TESTNET_ROOT_IPS}" != "[]" ]; then
              echo "Creating Testnet gossip configuration..."
              cat > "$$HOME/override_gossip_config.json" <<EOF
        { "root_node_ips": $${TESTNET_ROOT_IPS}, "try_new_peers": false, "chain": "Testnet", "reserved_peer_ips": $${RESERVED_PEERS} }
        EOF
              echo "✅ Created Testnet gossip config"
            else
              echo "ℹ️  Using default peers for Testnet"
              rm -f "$$HOME/override_gossip_config.json"
            fi
          else
            echo "⚠️  Unknown CHAIN value: $${CHAIN}"
          fi
        }

        # Function to create firewall config (same logic as docker-entrypoint.sh)
        create_firewall_config() {
          local firewall_dir="$$HOME/hl/file_mod_time_tracker"
          local firewall_file="$$firewall_dir/firewall_ips.json"

          mkdir -p "$$firewall_dir"

          if [ -n "$${FIREWALL_IPS}" ] && [ "$${FIREWALL_IPS}" != "[]" ]; then
            echo "Creating firewall configuration..."

            # Validate JSON format first
            if ! echo "$${FIREWALL_IPS}" | jq . >/dev/null 2>&1; then
              echo "❌ Error: FIREWALL_IPS contains invalid JSON format"
              return 1
            fi

            # Parse and convert to required format
            if echo "$${FIREWALL_IPS}" | jq 'map([.ip, {"name": .name, "allowed": .allowed}])' > "$$firewall_file" && [ -s "$$firewall_file" ]; then
              echo "✅ Successfully created firewall configuration"
              echo "Firewall IPs configured:"
              jq -r '.[] | "  \(.[0]) - \(.[1].name) (allowed: \(.[1].allowed))"' "$$firewall_file"
            else
              echo "❌ Error: Failed to create firewall configuration file"
              return 1
            fi
          else
            echo "Creating empty firewall configuration..."
            echo "[]" > "$$firewall_file"
            echo "✅ Created empty firewall configuration"
          fi
        }

        # Show current environment
        echo "Current configuration:"
        echo "  CHAIN: $${CHAIN:-<not set>}"
        echo "  MAINNET_ROOT_IPS: $${MAINNET_ROOT_IPS:-<not set>}"
        echo "  TESTNET_ROOT_IPS: $${TESTNET_ROOT_IPS:-<not set>}"
        echo "  RESERVED_PEER_IPS: $${RESERVED_PEER_IPS:-<not set>}"
        echo "  FIREWALL_IPS: $${FIREWALL_IPS:-<not set>}"
        echo

        # Apply configurations
        create_gossip_config
        create_firewall_config

        echo
        echo "✅ Configuration sync completed!"
        echo "The running consensus node will pick up these changes."
    <<: *logging



volumes:
  consensus-data:
